#!/bin/bash

# This reduces hotpatch usage from 75 MiB RSS to 11 MiB
JVMOPTS="-Xint -XX:+UseSerialGC"

MIN_WAIT=0
WAIT_DELAY=0

# sbin is not included when run as a cron job
PATH="/sbin:/usr/sbin:$PATH"

function log() {
    echo "[log4j-hotpatch] $@"

    # Do not fail if syslog is being wonky
    logger -d -p user.notice "$*" || true
}

function extract_euid() {
    PID="$1"

    UIDS=$(grep '^Uid:' /proc/$PID/status | cut -f2- -d:)
    RC=$?
    if test "$RC" != 0; then
       return $RC
    fi
	    
    echo $UIDS | cut -f 2 -d' '
}

function pidof_sorted() {
    ALL_PIDS=$(pidof "$@")
    RC=$?
    if test "$RC" -ne 0; then
	return $RC
    fi

    echo $(for pid in $ALL_PIDS; do echo $pid; done | sort)
}

function now() {
    date "+%s"
}

function apply_patch() {
    log "Starting up now..."

    # Remove these early such that an premature exit doesn't result in a false
    # result.
    rm -f /dev/shm/log4j-cve-2021-44228-hotpatch.good
    rm -f /dev/shm/log4j-cve-2021-44228-hotpatch.bad

    PATCHED_JVMS=0
    TOTAL_JVMS=0

    PIDS=$(pidof_sorted java)
    RC=$?
    if test "$RC" = "0"; then
	log "Found JVMs with pids [$PIDS]"
	for pid in $PIDS; do
	    log "Attempting to patch $pid"

	    # AL1 version of nsenter doesn't support "--all"; specify namespaces separately
	    NSENTER="sudo nsenter -t ${pid} -m -n -i -u -p"
	    # Check if the PID is associated with a container.
	    # Get the PID in the lowest namespace; if this isn't the same as the
	    # PID we see, then we need to use nsenter for operations below
	    container_pid=$(echo $(grep "^NSpid:" /proc/$pid/status) | awk '{ print $NF }')
	    if [ "$container_pid" != "$pid" ]; then
		log "Running in a container with container pid: $container_pid"
	    else
		container_pid=""
	    fi
	    TOTAL_JVMS=$(($TOTAL_JVMS + 1))

	    JVM=$(readlink /proc/$pid/exe)
	    RC=$?
	    if test "$RC" -ne "0"; then
		log "Failed to read exe name from pid $pid, skipping."
		continue
	    fi

	    log "Found JVM for pid $pid at $JVM"

	    MYEUID=$(extract_euid $pid)
	    RC=$?
	    if test "$RC" -ne "0"; then
		log "Failed to find effective UID for pid $pid, skipping."
		continue
	    fi

	    log "Found JVM running with effective UID of $MYEUID"

	    if [ ! -z "$container_pid" ]; then
		# Get the java version from within the container.
		FULL_VERSION_OUT=$(${NSENTER} "$JVM" -version 2>&1)
		RC=$?
		FULL_VERSION=$(echo "${FULL_VERSION_OUT}" | head -1)
	    else
		FULL_VERSION_OUT=$("$JVM" -version 2>&1)
		RC=$?
		FULL_VERSION=$(echo "${FULL_VERSION_OUT}" | head -1)
	    fi
	    if test "$RC" -ne "0"; then
		log "Failed to execute JVM to determine version, skipping"
		continue
	    fi

	    log "JVM version is $FULL_VERSION"

	    KIND=$(echo $FULL_VERSION | cut -f1 -d' ')
	    SEMVER=$(echo $FULL_VERSION | cut -f3 -d' ' | sed -e 's:"::g')
	    MAJOR=$(echo $SEMVER | cut -f1 -d'.')
	    MAJMIN=$(echo $SEMVER | cut -f1-2 -d'.')

	    if test "$KIND" != "openjdk" -a "$KIND" != "java"; then
		log "Skipping unsupported JVM kind: $KIND"
		continue
	    fi

	    log "Identified JVM[$KIND] of ($FULL_VERSION) with major version $MAJOR"

	    if test "$MAJOR" = "11" -o "$MAJOR" = "15"; then
			log "Using Java 11 hotpatch"

			if [ ! -z "$container_pid" ]; then
					# Copy the jar into the container. We copy to shm since the filesystem within the container is otherwise not predictable. 
					cat /usr/share/log4j-cve-2021-44228-hotpatch/jdk11/Log4jHotPatch.jar | ${NSENTER} sh -c "cat >/dev/shm/Log4jHotPatch.jar"
					${NSENTER} -S "$MYEUID" "$JVM" $JVMOPTS -cp /dev/shm/Log4jHotPatch.jar Log4jHotPatch $container_pid
				RC=$?
						# Clean up the jar file from container's shm.
					${NSENTER} rm -f /dev/shm/Log4jHotPatch.jar
			else
					sudo -u "#$MYEUID" "$JVM" $JVMOPTS -cp /usr/share/log4j-cve-2021-44228-hotpatch/jdk11/Log4jHotPatch.jar Log4jHotPatch $pid
				RC=$?
			fi
			
			log "Hotpatch application returned $RC"

			if test "$RC" = 0; then
				PATCHED_JVMS=$(($PATCHED_JVMS + 1))
			fi
	    elif test "$MAJOR" = "17"; then
			log "Using Java 17 hotpatch"

			if [ ! -z "$container_pid" ]; then
					# Copy the jar into the container. We copy to shm since the filesystem within the container is otherwise not predictable. 
					cat /usr/share/log4j-cve-2021-44228-hotpatch/jdk17/Log4jHotPatchFat.jar | ${NSENTER} sh -c "cat >/dev/shm/Log4jHotPatchFat.jar"
					${NSENTER} -S "$MYEUID" "$JVM" $JVMOPTS -cp /dev/shm/Log4jHotPatchFat.jar \
					-DfatJar=/dev/shm/Log4jHotPatchFat.jar Log4jHotPatch17 $container_pid
				RC=$?
				# Clean up the jar file from container's shm.
					${NSENTER} rm -f /dev/shm/Log4jHotPatchFat.jar
			else
					sudo -u "#$MYEUID" "$JVM" $JVMOPTS -cp /dev/shm/Log4jHotPatchFat.jar \
				-DfatJar=/usr/share/log4j-cve-2021-44228-hotpatch/jdk17/Log4jHotPatchFat.jar Log4jHotPatch17 $pid
						RC=$?
			fi
			log "Hotpatch application returned $RC"

			if test "$RC" = 0; then
				PATCHED_JVMS=$(($PATCHED_JVMS + 1))
			fi
	    elif test "$MAJMIN" = "1.8"; then
			log "Using Java 8 hotpatch"

			BINDIR=$(dirname "$JVM")
			log "Extracted BINDIR of $BINDIR"

			BASEDIR=$(dirname "$BINDIR")
			log "Extracted BASEDIR of $BASEDIR"

			DIRNAME=$(basename "$BASEDIR")
			log "Extracted DIRNAME of $DIRNAME"

			# Sometimes java is invoked as $JAVAHOME/jre/bin/java verses $JAVAHOME/bin/java, try to correct for this.
			if test "$DIRNAME" = "jre"; then
				BASEDIR=$(dirname "$BASEDIR")
			fi

			if [ ! -z "$container_pid" ]; then
					if ! ${NSENTER} test -e "$BASEDIR/lib/tools.jar"; then
				log "Could not find tools.jar in JVM lib, skipping"
				continue
					fi
			else
				if ! test -e "$BASEDIR/lib/tools.jar"; then
				log "Could not find tools.jar in JVM lib, skipping"
				continue
					fi
			fi
			
			if [ ! -z "$container_pid" ]; then
					# Copy the jar into the container. We copy to shm since the filesystem within the container is otherwise not predictable. 
				cat /usr/share/log4j-cve-2021-44228-hotpatch/jdk8/Log4jHotPatch.jar | ${NSENTER} sh -c "cat >/dev/shm/Log4jHotPatch.jar"
				${NSENTER} -S "$MYEUID" "$JVM" $JVMOPTS -cp "$BASEDIR/lib/tools.jar:/dev/shm/Log4jHotPatch.jar" Log4jHotPatch $container_pid
				RC=$?
				# Clean up the jar file from container's shm.
					${NSENTER} rm -f /dev/shm/Log4jHotPatch.jar
			else
					sudo -u "#$MYEUID" "$JVM" $JVMOPTS -cp "$BASEDIR/lib/tools.jar:/usr/share/log4j-cve-2021-44228-hotpatch/jdk8/Log4jHotPatch.jar" Log4jHotPatch $pid
				RC=$?
			fi

			log "Hotpatch application returned $RC"

			if test "$RC" = 0; then
				PATCHED_JVMS=$(($PATCHED_JVMS + 1))
			fi
	    else
			log "Unsupported Java major version $MAJOR, skipping"
	    fi
	done
    else
	log "No JVMs found, exiting gracefully"
    fi

    # Leave a file to indicate that we're either patched or unpatched
    if test "$PATCHED_JVMS" -lt "$TOTAL_JVMS"; then
		touch /dev/shm/log4j-cve-2021-44228-hotpatch.bad
    else
		touch /dev/shm/log4j-cve-2021-44228-hotpatch.good
    fi
}

function main() {
    while test "$1"; do
	OPT="$1"
	shift
	
	case "$OPT" in
	    -w)
		WAIT_DELAY="$1"
		shift
		;;
	    -m)
		MIN_WAIT="$1"
		shift
		;;
	    *)
		echo "Unexpected option '$OPT'"
		break
		;;
	esac
    done

    # This file allows disabling the hotpatch from being reapplied
    # in case something goes wrong and we need an Andon Cord.
    if test -e /dev/shm/log4j-cve-2021-44228-hotpatch.kill -o -e /etc/log4j-cve-2021-44228-hotpatch.kill; then
	log "Found kill file, not applying patch."
    else
	apply_patch
    fi

    sleep "$MIN_WAIT"

    START="$(now)"
    NOW="$START"
    END=$(($START + $WAIT_DELAY))

    while test "$NOW" -lt "$END"; do
	NEW_PIDS=$(pidof_sorted java)

	if test "$PIDS" = "$NEW_PIDS"; then
	    sleep 1
	else
	    break
	fi

	NOW="$(now)"
    done
}

main "$@"
